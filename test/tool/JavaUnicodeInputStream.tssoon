/*
 * Copyright 2016 Terence Parr, Sam Harwell, and Burt Harris
 * All rights reserved.
 * Licensed under the BSD-3-clause license. See LICENSE file in the project root for license information.
 */

// ConvertTo-TS run at 2016-10-04T11:27:01.9391717-07:00

/**
 *
 * @author Sam Harwell
 */
export class JavaUnicodeInputStream implements CharStream {
	@NotNull
	private source: CharStream; 
	private escapeIndexes: IntegerList =  new IntegerList();
	private escapeCharacters: IntegerList =  new IntegerList();
	private escapeIndirectionLevels: IntegerList =  new IntegerList();

	private escapeListIndex: number; 
	private range: number; 
	private slashCount: number; 

	private la1: number; 

	 constructor(@NotNull source: CharStream)  {
		if (source == null) {
			throw new NullPointerException("source");
		}

		this.source = source;
		this.la1 = source.LA(1);
	}

	@Override
	size(): number {
		return source.size();
	}

	@Override
	index(): number {
		return source.index();
	}

	@Override
	getSourceName(): string {
		return source.getSourceName();
	}

	@Override
	getText(interval: Interval): string {
		return source.getText(interval);
	}

	@Override
	consume(): void {
		if (la1 != '\\') {
			source.consume();
			la1 = source.LA(1);
			range = Math.max(range, source.index());
			slashCount = 0;
			return;
		}

		// make sure the next character has been processed
		this.LA(1);

		if (escapeListIndex >= escapeIndexes.size() || escapeIndexes.get(escapeListIndex) != index()) {
			source.consume();
			slashCount++;
		}
		else {
			let indirectionLevel: number =  escapeIndirectionLevels.get(escapeListIndex);
			for (let i = 0; i < 6 + indirectionLevel; i++) {
				source.consume();
			}

			escapeListIndex++;
			slashCount = 0;
		}

		la1 = source.LA(1);
		assert(range >= index());
	}

	@Override
	LA(i: number): number {
		if (i == 1 && la1 != '\\') {
			return la1;
		}

		if (i <= 0) {
			let desiredIndex: number =  index() + i;
			for (let j = escapeListIndex - 1; j >= 0; j--) {
				if (escapeIndexes.get(j) + 6 + escapeIndirectionLevels.get(j) > desiredIndex) {
					desiredIndex -= 5 + escapeIndirectionLevels.get(j);
				}

				if (escapeIndexes.get(j) == desiredIndex) {
					return escapeCharacters.get(j);
				}
			}

			return source.LA(desiredIndex - index());
		}
		else {
			let desiredIndex: number =  index() + i - 1;
			for (let j = escapeListIndex; j < escapeIndexes.size(); j++) {
				if (escapeIndexes.get(j) == desiredIndex) {
					return escapeCharacters.get(j);
				}
				else if (escapeIndexes.get(j) < desiredIndex) {
					desiredIndex += 5 + escapeIndirectionLevels.get(j);
				}
				else {
					return source.LA(desiredIndex - index() + 1);
				}
			}

			let currentIndex: number[] =  { index() };
			let slashCountPtr: number[] =  { slashCount };
			let indirectionLevelPtr: number[] =  { 0 };
			for (let j = 0; j < i; j++) {
				let previousIndex: number =  currentIndex[0];
				let c: number =  readCharAt(currentIndex, slashCountPtr, indirectionLevelPtr);
				if (currentIndex[0] > range) {
					if (currentIndex[0] - previousIndex > 1) {
						escapeIndexes.add(previousIndex);
						escapeCharacters.add(c);
						escapeIndirectionLevels.add(indirectionLevelPtr[0]);
					}

					range = currentIndex[0];
				}

				if (j == i - 1) {
					return c;
				}
			}

			throw new IllegalStateException("shouldn't be reachable");
		}
	}

	@Override
	mark(): number {
		return source.mark();
	}

	@Override
	release(marker: number): void {
		source.release(marker);
	}

	@Override
	seek(index: number): void {
		if (index > range) {
			throw new UnsupportedOperationException();
		}

		source.seek(index);
		la1 = source.LA(1);

		slashCount = 0;
		while (source.LA(-slashCount - 1) == '\\') {
			slashCount++;
		}

		escapeListIndex = escapeIndexes.binarySearch(source.index());
		if (escapeListIndex < 0) {
			escapeListIndex = -escapeListIndex - 1;
		}
	}

	private static isHexDigit(c: number): boolean {
		return c >= '0' && c <= '9'
			|| c >= 'a' && c <= 'f'
			|| c >= 'A' && c <= 'F';
	}

	private static hexValue(c: number): number {
		if (c >= '0' && c <= '9') {
			return c - '0';
		}

		if (c >= 'a' && c <= 'f') {
			return c - 'a' + 10;
		}

		if (c >= 'A' && c <= 'F') {
			return c - 'A' + 10;
		}

		throw new IllegalArgumentException("c");
	}

	private readCharAt(nextIndexPtr: number[], slashCountPtr: number[], indirectionLevelPtr: number[]): number {
		assert(nextIndexPtr != null && nextIndexPtr.length == 1);
		assert(slashCountPtr != null && slashCountPtr.length == 1);
		assert(indirectionLevelPtr != null && indirectionLevelPtr.length == 1);

		let blockUnicodeEscape: boolean =  (slashCountPtr[0] % 2) != 0;

		let c0: number =  source.LA(nextIndexPtr[0] - index() + 1);
		if (c0 == '\\') {
			slashCountPtr[0]++;

			if (!blockUnicodeEscape) {
				let c1: number =  source.LA(nextIndexPtr[0] - index() + 2);
				if (c1 == 'u') {
					let c2: number =  source.LA(nextIndexPtr[0] - index() + 3);
					indirectionLevelPtr[0] = 0;
					while (c2 == 'u') {
						indirectionLevelPtr[0]++;
						c2 = source.LA(nextIndexPtr[0] - index() + 3 + indirectionLevelPtr[0]);
					}

					let c3: number =  source.LA(nextIndexPtr[0] - index() + 4 + indirectionLevelPtr[0]);
					let c4: number =  source.LA(nextIndexPtr[0] - index() + 5 + indirectionLevelPtr[0]);
					let c5: number =  source.LA(nextIndexPtr[0] - index() + 6 + indirectionLevelPtr[0]);
					if (isHexDigit(c2) && isHexDigit(c3) && isHexDigit(c4) && isHexDigit(c5)) {
						let value: number =  hexValue(c2);
						value = (value << 4) + hexValue(c3);
						value = (value << 4) + hexValue(c4);
						value = (value << 4) + hexValue(c5);

						nextIndexPtr[0] += 6 + indirectionLevelPtr[0];
						slashCountPtr[0] = 0;
						return value;
					}
				}
			}
		}

		nextIndexPtr[0]++;
		return c0;
	}
}
