/*
 * Copyright 2016 Terence Parr, Sam Harwell, and Burt Harris
 * All rights reserved.
 * Licensed under the BSD-3-clause license. See LICENSE file in the project root for license information.
 */
// ConvertTo-TS run at 2016-10-04T11:26:58.1768850-07:00

/**
 * Useful for rewriting out a buffered input token stream after doing some
 * augmentation or other manipulations on it.
 *
 * <p>
 * You can insert stuff, replace, and delete chunks. Note that the operations
 * are done lazily--only if you convert the buffer to a {@link String} with
 * {@link TokenStream#getText()}. This is very efficient because you are not
 * moving data around all the time. As the buffer of tokens is converted to
 * strings, the {@link #getText()} method(s) scan the input token stream and
 * check to see if there is an operation at the current index. If so, the
 * operation is done and then normal {@link String} rendering continues on the
 * buffer. This is like having multiple Turing machine instruction streams
 * (programs) operating on a single input tape. :)</p>
 *
 * <p>
 * This rewriter makes no modifications to the token stream. It does not ask the
 * stream to fill itself up nor does it advance the input cursor. The token
 * stream {@link TokenStream#index()} will return the same value before and
 * after any {@link #getText()} call.</p>
 *
 * <p>
 * The rewriter only works on tokens that you have in the buffer and ignores the
 * current input cursor. If you are buffering tokens on-demand, calling
 * {@link #getText()} halfway through the input will only do rewrites for those
 * tokens in the first half of the file.</p>
 *
 * <p>
 * Since the operations are done lazily at {@link #getText}-time, operations do
 * not screw up the token index values. That is, an insert operation at token
 * index {@code i} does not change the index values for tokens
 * {@code i}+1..n-1.</p>
 *
 * <p>
 * Because operations never actually alter the buffer, you may always get the
 * original token stream back without undoing anything. Since the instructions
 * are queued up, you can easily simulate transactions and roll back any changes
 * if there is an error just by removing instructions. For example,</p>
 *
 * <pre>
 * CharStream input = new ANTLRFileStream("input");
 * TLexer lex = new TLexer(input);
 * CommonTokenStream tokens = new CommonTokenStream(lex);
 * T parser = new T(tokens);
 * TokenStreamRewriter rewriter = new TokenStreamRewriter(tokens);
 * parser.startRule();
 * </pre>
 *
 * <p>
 * Then in the rules, you can execute (assuming rewriter is visible):</p>
 *
 * <pre>
 * Token t,u;
 * ...
 * rewriter.insertAfter(t, "text to put after t");}
 * rewriter.insertAfter(u, "text after u");}
 * System.out.println(rewriter.getText());
 * </pre>
 *
 * <p>
 * You can also have multiple "instruction streams" and get multiple rewrites
 * from a single pass over the input. Just name the instruction streams and use
 * that name again when printing the buffer. This could be useful for generating
 * a C file and also its header file--all from the same buffer:</p>
 *
 * <pre>
 * rewriter.insertAfter("pass1", t, "text to put after t");}
 * rewriter.insertAfter("pass2", u, "text after u");}
 * System.out.println(rewriter.getText("pass1"));
 * System.out.println(rewriter.getText("pass2"));
 * </pre>
 *
 * <p>
 * If you don't use named rewrite streams, a "default" stream is used as the
 * first example shows.</p>
 */
export class TokenStreamRewriter {
	static DEFAULT_PROGRAM_NAME: string =  "default";
	static PROGRAM_INIT_SIZE: number =  100;
	static MIN_TOKEN_INDEX: number =  0;

	// Define the rewrite operation hierarchy

	public static class RewriteOperation {
		protected tokens: TokenStream; 
	/** What index into rewrites List are we? */
	protected instructionIndex: number; 
	/** Token buffer index. */
	protected index: number; 
		protected text: any; 

		protected RewriteOperation(TokenStream tokens, int index) {
			this.tokens = tokens;
			this.index = index;
		}

		protected RewriteOperation(TokenStream tokens, int index, Object text) {
			this.tokens = tokens;
			this.index = index;
			this.text = text;
		}
		/** Execute the rewrite operation by possibly adding to the buffer.
		 *  Return the index of the next token to operate on.
		 */
		execute(buf: StringBuilder): number {
			return index;
		}

		@Override
		toString(): string {
			let opName: string =  getClass().getName();
			int $index = opName.indexOf('$');
			opName = opName.substring($index+1, opName.length());
			return "<"+opName+"@"+tokens.get(index)+
					":\""+text+"\">";
		}
	}

	static class InsertBeforeOp extends RewriteOperation {
		public InsertBeforeOp(TokenStream tokens, int index, Object text) {
			super(tokens,index,text);
		}

		@Override
		execute(buf: StringBuilder): number {
			buf.append(text);
			if ( tokens.get(index).getType()!=Token.EOF ) {
				buf.append(tokens.get(index).getText());
			}
			return index+1;
		}
	}

	/** I'm going to try replacing range from x..y with (y-x)+1 ReplaceOp
	 *  instructions.
	 */
	static class ReplaceOp extends RewriteOperation {
		protected lastIndex: number; 
		public ReplaceOp(TokenStream tokens, int from, int to, Object text) {
			super(tokens, from,text);
			lastIndex = to;
		}
		@Override
		execute(buf: StringBuilder): number {
			if ( text!=null ) {
				buf.append(text);
			}
			return lastIndex+1;
		}
		@Override
		toString(): string {
			if ( text==null ) {
				return "<DeleteOp@"+tokens.get(index)+
						".."+tokens.get(lastIndex)+">";
			}
			return "<ReplaceOp@"+tokens.get(index)+
					".."+tokens.get(lastIndex)+":\""+text+"\">";
		}
	}

	/** Our source stream */
	protected tokens: TokenStream; 

	/** You may have multiple, named streams of rewrite operations.
	 *  I'm calling these things "programs."
	 *  Maps String (name) &rarr; rewrite (List)
	 */
	protected programs: Map<string, List<RewriteOperation>>; 

	/** Map String (program name) &rarr; Integer index */
	protected lastRewriteTokenIndexes: Map<string, number>; 

	 constructor(tokens: TokenStream)  {
		this.tokens = tokens;
		programs = new HashMap<String, List<RewriteOperation>>();
		programs.put(DEFAULT_PROGRAM_NAME,
					 new ArrayList<RewriteOperation>(PROGRAM_INIT_SIZE));
		lastRewriteTokenIndexes = new HashMap<String, Integer>();
	}

	getTokenStream(): TokenStream {
		return tokens;
	}

	rollback(instructionIndex: number): void {
		rollback(DEFAULT_PROGRAM_NAME, instructionIndex);
	}

	/** Rollback the instruction stream for a program so that
	 *  the indicated instruction (via instructionIndex) is no
	 *  longer in the stream. UNTESTED!
	 */
	rollback(programName: string, instructionIndex: number): void {
		let is: List<RewriteOperation> =  programs.get(programName);
		if ( is!=null ) {
			programs.put(programName, is.subList(MIN_TOKEN_INDEX,instructionIndex));
		}
	}

	deleteProgram(): void {
		deleteProgram(DEFAULT_PROGRAM_NAME);
	}

	/** Reset the program so that no instructions exist */
	deleteProgram(programName: string): void {
		rollback(programName, MIN_TOKEN_INDEX);
	}

	insertAfter(t: Token, text: any): void {
		insertAfter(DEFAULT_PROGRAM_NAME, t, text);
	}

	insertAfter(index: number, text: any): void {
		insertAfter(DEFAULT_PROGRAM_NAME, index, text);
	}

	insertAfter(programName: string, t: Token, text: any): void {
		insertAfter(programName,t.getTokenIndex(), text);
	}

	insertAfter(programName: string, index: number, text: any): void {
		// to insert after, just insert before next index (even if past end)
		insertBefore(programName,index+1, text);
	}

	insertBefore(t: Token, text: any): void {
		insertBefore(DEFAULT_PROGRAM_NAME, t, text);
	}

	insertBefore(index: number, text: any): void {
		insertBefore(DEFAULT_PROGRAM_NAME, index, text);
	}

	insertBefore(programName: string, t: Token, text: any): void {
		insertBefore(programName, t.getTokenIndex(), text);
	}

	insertBefore(programName: string, index: number, text: any): void {
		let op: RewriteOperation =  new InsertBeforeOp(tokens,index,text);
		let rewrites: List<RewriteOperation> =  getProgram(programName);
		op.instructionIndex = rewrites.size();
		rewrites.add(op);
	}

	replace(index: number, text: any): void {
		replace(DEFAULT_PROGRAM_NAME, index, index, text);
	}

	replace(from: number, to: number, text: any): void {
		replace(DEFAULT_PROGRAM_NAME, from, to, text);
	}

	replace(indexT: Token, text: any): void {
		replace(DEFAULT_PROGRAM_NAME, indexT, indexT, text);
	}

	replace(from: Token, to: Token, text: any): void {
		replace(DEFAULT_PROGRAM_NAME, from, to, text);
	}

	replace(programName: string, from: number, to: number, @Nullable text: any): void {
		if ( from > to || from<0 || to<0 || to >= tokens.size() ) {
			throw new IllegalArgumentException("replace: range invalid: "+from+".."+to+"(size="+tokens.size()+")");
		}
		let op: RewriteOperation =  new ReplaceOp(tokens, from, to, text);
		let rewrites: List<RewriteOperation> =  getProgram(programName);
		op.instructionIndex = rewrites.size();
		rewrites.add(op);
	}

	replace(programName: string, from: Token, to: Token, @Nullable text: any): void {
		replace(programName,
				from.getTokenIndex(),
				to.getTokenIndex(),
				text);
	}

	delete(index: number): void {
		delete(DEFAULT_PROGRAM_NAME, index, index);
	}

	delete(from: number, to: number): void {
		delete(DEFAULT_PROGRAM_NAME, from, to);
	}

	delete(indexT: Token): void {
		delete(DEFAULT_PROGRAM_NAME, indexT, indexT);
	}

	delete(from: Token, to: Token): void {
		delete(DEFAULT_PROGRAM_NAME, from, to);
	}

	delete(programName: string, from: number, to: number): void {
		replace(programName,from,to,null);
	}

	delete(programName: string, from: Token, to: Token): void {
		replace(programName,from,to,null);
	}

	getLastRewriteTokenIndex(): number {
		return getLastRewriteTokenIndex(DEFAULT_PROGRAM_NAME);
	}

	protected getLastRewriteTokenIndex(programName: string): number {
		let I: number =  lastRewriteTokenIndexes.get(programName);
		if ( I==null ) {
			return -1;
		}
		return I;
	}

	protected setLastRewriteTokenIndex(programName: string, i: number): void {
		lastRewriteTokenIndexes.put(programName, i);
	}

	protected getProgram(name: string): List<RewriteOperation> {
		let is: List<RewriteOperation> =  programs.get(name);
		if ( is==null ) {
			is = initializeProgram(name);
		}
		return is;
	}

	private initializeProgram(name: string): List<RewriteOperation> {
		let is: List<RewriteOperation> =  new ArrayList<RewriteOperation>(PROGRAM_INIT_SIZE);
		programs.put(name, is);
		return is;
	}

	/** Return the text from the original tokens altered per the
	 *  instructions given to this rewriter.
 	 */
	getText(): string {
		return getText(DEFAULT_PROGRAM_NAME, Interval.of(0,tokens.size()-1));
	}

	/** Return the text from the original tokens altered per the
	 *  instructions given to this rewriter in programName.
	 *
	 * @since 4.5
 	 */
	getText(programName: string): string {
		return getText(programName, Interval.of(0,tokens.size()-1));
	}

	/** Return the text associated with the tokens in the interval from the
	 *  original token stream but with the alterations given to this rewriter.
	 *  The interval refers to the indexes in the original token stream.
	 *  We do not alter the token stream in any way, so the indexes
	 *  and intervals are still consistent. Includes any operations done
	 *  to the first and last token in the interval. So, if you did an
	 *  insertBefore on the first token, you would get that insertion.
	 *  The same is true if you do an insertAfter the stop token.
 	 */
	getText(interval: Interval): string {
		return getText(DEFAULT_PROGRAM_NAME, interval);
	}

	getText(programName: string, interval: Interval): string {
		let rewrites: List<RewriteOperation> =  programs.get(programName);
		let start: number =  interval.a;
		let stop: number =  interval.b;

		// ensure start/end are in range
		if ( stop>tokens.size()-1 ) stop = tokens.size()-1;
		if ( start<0 ) start = 0;

		if ( rewrites==null || rewrites.isEmpty() ) {
			return tokens.getText(interval); // no instructions to execute
		}
		let buf: StringBuilder =  new StringBuilder();

		// First, optimize instruction stream
		let indexToOp: Map<number, RewriteOperation> =  reduceToSingleOperationPerIndex(rewrites);

		// Walk buffer, executing instructions and emitting tokens
		let i: number =  start;
		while ( i <= stop && i < tokens.size() ) {
			let op: RewriteOperation =  indexToOp.get(i);
			indexToOp.remove(i); // remove so any left have index size-1
			let t: Token =  tokens.get(i);
			if ( op==null ) {
				// no operation at that index, just dump token
				if ( t.getType()!=Token.EOF ) buf.append(t.getText());
				i++; // move to next token
			}
			else {
				i = op.execute(buf); // execute operation and skip
			}
		}

		// include stuff after end if it's last index in buffer
		// So, if they did an insertAfter(lastValidIndex, "foo"), include
		// foo if end==lastValidIndex.
		if ( stop==tokens.size()-1 ) {
			// Scan any remaining operations after last token
			// should be included (they will be inserts).
			for (let op of indexToOp.values()) {
				if ( op.index >= tokens.size()-1 ) buf.append(op.text);
			}
		}
		return buf.toString();
	}

	/** We need to combine operations and report invalid operations (like
	 *  overlapping replaces that are not completed nested). Inserts to
	 *  same index need to be combined etc...  Here are the cases:
	 *
	 *  I.i.u I.j.v								leave alone, nonoverlapping
	 *  I.i.u I.i.v								combine: Iivu
	 *
	 *  R.i-j.u R.x-y.v	| i-j in x-y			delete first R
	 *  R.i-j.u R.i-j.v							delete first R
	 *  R.i-j.u R.x-y.v	| x-y in i-j			ERROR
	 *  R.i-j.u R.x-y.v	| boundaries overlap	ERROR
	 *
	 *  Delete special case of replace (text==null):
	 *  D.i-j.u D.x-y.v	| boundaries overlap	combine to max(min)..max(right)
	 *
	 *  I.i.u R.x-y.v | i in (x+1)-y			delete I (since insert before
	 *											we're not deleting i)
	 *  I.i.u R.x-y.v | i not in (x+1)-y		leave alone, nonoverlapping
	 *  R.x-y.v I.i.u | i in x-y				ERROR
	 *  R.x-y.v I.x.u 							R.x-y.uv (combine, delete I)
	 *  R.x-y.v I.i.u | i not in x-y			leave alone, nonoverlapping
	 *
	 *  I.i.u = insert u before op @ index i
	 *  R.x-y.u = replace x-y indexed tokens with u
	 *
	 *  First we need to examine replaces. For any replace op:
	 *
	 * 		1. wipe out any insertions before op within that range.
	 *		2. Drop any replace op before that is contained completely within
	 *	 that range.
	 *		3. Throw exception upon boundary overlap with any previous replace.
	 *
	 *  Then we can deal with inserts:
	 *
	 * 		1. for any inserts to same index, combine even if not adjacent.
	 * 		2. for any prior replace with same left boundary, combine this
	 *	 insert with replace and delete this replace.
	 * 		3. throw exception if index in same range as previous replace
	 *
	 *  Don't actually delete; make op null in list. Easier to walk list.
	 *  Later we can throw as we add to index &rarr; op map.
	 *
	 *  Note that I.2 R.2-2 will wipe out I.2 even though, technically, the
	 *  inserted stuff would be before the replace range. But, if you
	 *  add tokens in front of a method body '{' and then delete the method
	 *  body, I think the stuff before the '{' you added should disappear too.
	 *
	 *  Return a map from token index to operation.
	 */
	protected reduceToSingleOperationPerIndex(rewrites: List<RewriteOperation>): Map<number, RewriteOperation> {
//		System.out.println("rewrites="+rewrites);

		// WALK REPLACES
		for (let i = 0; i < rewrites.size(); i++) {
			let op: RewriteOperation =  rewrites.get(i);
			if ( op==null ) continue;
			if ( !(op instanceof ReplaceOp) ) continue;
			let rop: ReplaceOp =  (ReplaceOp)rewrites.get(i);
			// Wipe prior inserts within range
			let inserts: List<? extends InsertBeforeOp> =  getKindOfOps(rewrites, InsertBeforeOp.class, i);
			for (let iop of inserts) {
				if ( iop.index == rop.index ) {
					// E.g., insert before 2, delete 2..2; update replace
					// text to include insert before, kill insert
					rewrites.set(iop.instructionIndex, null);
					rop.text = iop.text.toString() + (rop.text!=null?rop.text.toString():"");
				}
				else if ( iop.index > rop.index && iop.index <= rop.lastIndex ) {
					// delete insert as it's a no-op.
					rewrites.set(iop.instructionIndex, null);
				}
			}
			// Drop any prior replaces contained within
			let prevReplaces: List<? extends ReplaceOp> =  getKindOfOps(rewrites, ReplaceOp.class, i);
			for (let prevRop of prevReplaces) {
				if ( prevRop.index>=rop.index && prevRop.lastIndex <= rop.lastIndex ) {
					// delete replace as it's a no-op.
					rewrites.set(prevRop.instructionIndex, null);
					continue;
				}
				// throw exception unless disjoint or identical
				let disjoint: boolean = 
					prevRop.lastIndex<rop.index || prevRop.index > rop.lastIndex;
				let same: boolean = 
					prevRop.index==rop.index && prevRop.lastIndex==rop.lastIndex;
				// Delete special case of replace (text==null):
				// D.i-j.u D.x-y.v	| boundaries overlap	combine to max(min)..max(right)
				if ( prevRop.text==null && rop.text==null && !disjoint ) {
					//System.out.println("overlapping deletes: "+prevRop+", "+rop);
					rewrites.set(prevRop.instructionIndex, null); // kill first delete
					rop.index = Math.min(prevRop.index, rop.index);
					rop.lastIndex = Math.max(prevRop.lastIndex, rop.lastIndex);
					console.log("new rop "+rop);
				}
				else if ( !disjoint && !same ) {
					throw new IllegalArgumentException("replace op boundaries of "+rop+" overlap with previous "+prevRop);
				}
			}
		}

		// WALK INSERTS
		for (let i = 0; i < rewrites.size(); i++) {
			let op: RewriteOperation =  rewrites.get(i);
			if ( op==null ) continue;
			if ( !(op instanceof InsertBeforeOp) ) continue;
			let iop: InsertBeforeOp =  (InsertBeforeOp)rewrites.get(i);
			// combine current insert with prior if any at same index
			let prevInserts: List<? extends InsertBeforeOp> =  getKindOfOps(rewrites, InsertBeforeOp.class, i);
			for (let prevIop of prevInserts) {
				if ( prevIop.index == iop.index ) { // combine objects
					// convert to strings...we're in process of toString'ing
					// whole token buffer so no lazy eval issue with any templates
					iop.text = catOpText(iop.text,prevIop.text);
					// delete redundant prior insert
					rewrites.set(prevIop.instructionIndex, null);
				}
			}
			// look for replaces where iop.index is in range; error
			let prevReplaces: List<? extends ReplaceOp> =  getKindOfOps(rewrites, ReplaceOp.class, i);
			for (let rop of prevReplaces) {
				if ( iop.index == rop.index ) {
					rop.text = catOpText(iop.text,rop.text);
					rewrites.set(i, null);	// delete current insert
					continue;
				}
				if ( iop.index >= rop.index && iop.index <= rop.lastIndex ) {
					throw new IllegalArgumentException("insert op "+iop+" within boundaries of previous "+rop);
				}
			}
		}
		// System.out.println("rewrites after="+rewrites);
		let m: Map<number, RewriteOperation> =  new HashMap<Integer, RewriteOperation>();
		for (let i = 0; i < rewrites.size(); i++) {
			let op: RewriteOperation =  rewrites.get(i);
			if ( op==null ) continue; // ignore deleted ops
			if ( m.get(op.index)!=null ) {
				throw new Error("should only be one op per index");
			}
			m.put(op.index, op);
		}
		//System.out.println("index to op: "+m);
		return m;
	}

	protected catOpText(a: any, b: any): string {
		let x: string =  "";
		let y: string =  "";
		if ( a!=null ) x = a.toString();
		if ( b!=null ) y = b.toString();
		return x+y;
	}

	/** Get all operations before an index of a particular kind */
	protected getKindOfOps<T extends RewriteOperation>(kind: List<? extends RewriteOperation> rewrites,Class<T>, before: number): List<? extends T> {
		let ops: List<T> =  new ArrayList<T>();
		for (let i=0; i<before && i<rewrites.size(); i++) {
			let op: RewriteOperation =  rewrites.get(i);
			if ( op==null ) continue; // ignore deleted
			if ( kind.isInstance(op) ) {
				ops.add(kind.cast(op));
			}
		}
		return ops;
	}
}
